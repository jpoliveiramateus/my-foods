'use strict';

var filterReports = require('../filterReports');
var isReactReduxConnect = require('../isReactReduxConnect');

var noUnusedPropTypesReact = require('eslint-plugin-react').rules['no-unused-prop-types'];

var belongsToReduxReact = function belongsToReduxReact(node, objectName, destrArg) {
  var checkProp = function checkProp(secondArgument) {
    var secondArgumentName = secondArgument && secondArgument.type === 'Identifier' && secondArgument.name;
    return secondArgumentName === objectName // ownProps.myProp
    || destrArg === secondArgument // {myProp} in fn argument
    || destrArg && destrArg.parent.type === 'VariableDeclarator' && destrArg.parent.init && destrArg.parent.init.name === secondArgumentName // const {myProp} = ownProps;
    ;
  };
  var isReactRedux = false;
  if (node.type === 'VariableDeclaration') {
    node.declarations.forEach(function (decl) {
      var name = decl.id && decl.id.name;
      if (name === 'mapStateToProps' || name === 'mapDispatchToProps') {
        var secondArgument = decl.init.params && decl.init.params[1];
        if (checkProp(secondArgument)) {
          isReactRedux = true;
        }
      }
    });
  } else if (node.type === 'FunctionDeclaration') {
    var name = node.id && node.id.name;
    if (name === 'mapStateToProps' || name === 'mapDispatchToProps') {
      var secondArgument = node.params && node.params[1];
      if (checkProp(secondArgument)) {
        isReactRedux = true;
      }
    }
  } else if (node.type === 'CallExpression') {
    if (isReactReduxConnect(node)) {
      var check = function check(mapToProps) {
        if (mapToProps && mapToProps.body) {
          var _secondArgument = mapToProps.params && mapToProps.params[1];
          if (checkProp(_secondArgument)) {
            isReactRedux = true;
          }
        }
      };
      var mapStateToProps = node.arguments && node.arguments[0];
      var mapDispatchToProps = node.arguments && node.arguments[1];
      if (mapStateToProps) check(mapStateToProps);
      if (mapDispatchToProps) check(mapDispatchToProps);
    }
  }
  return isReactRedux;
};

var propsUsedInRedux = function propsUsedInRedux(context) {
  return {
    MemberExpression(node) {
      var nodeName = node.object.name;
      var usedInReactRedux = context.getAncestors().some(function (ancestor) {
        return belongsToReduxReact(ancestor, nodeName);
      });
      if (usedInReactRedux) {
        context.report(node, `exclude:${node.property.name}`);
      }
    },
    ObjectPattern(node) {
      var usedInReactRedux = context.getAncestors().some(function (ancestor) {
        return belongsToReduxReact(ancestor, null, node);
      });
      if (usedInReactRedux) {
        node.properties.forEach(function (prop) {
          if (prop.type === 'Property' && prop.key && prop.key.name) {
            return context.report(node, `exclude:${prop.key.name}`);
          } else if (prop.type === 'ExperimentalRestProperty' && prop.argument && prop.argument.name) {
            return context.report(node, `exclude:${prop.argument.name}`);
          }
          return undefined;
        });
      }
    }
  };
};

var getPropNameFromReactRuleMessage = function getPropNameFromReactRuleMessage(message) {
  return message.replace(' PropType is defined but prop is never used', '').replace("'", '').replace("'", '');
};
var getPropNameFromReduxRuleMessage = function getPropNameFromReduxRuleMessage(message) {
  return message.replace('exclude:', '');
};

module.exports = filterReports([propsUsedInRedux, noUnusedPropTypesReact], getPropNameFromReactRuleMessage, getPropNameFromReduxRuleMessage);